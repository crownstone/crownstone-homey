"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProjectLogger = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
const winston = require('winston');
require('winston-daily-rotate-file');
const util = require('util');
/** Setting up the formatter**/
function transform(info, opts) {
    const args = info[Symbol.for('splat')];
    if (args) {
        info.message = util.format(info.message, ...args);
    }
    return info;
}
function utilFormatter() { return { transform }; }
// @ts-ignore
let formatter = winston.format.printf(({ level, message, label, timestamp }) => `${timestamp} ${label || '-'} ${level}: ${message}`);
let aggregatedFormat = winston.format.combine(winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }), utilFormatter(), // <-- this is what changed
formatter);
// -----------------------------------
// CUSTOM LEVELS AND COLORS
const levels = {
    none: 0,
    critical: 1,
    error: 2,
    warn: 3,
    notice: 4,
    info: 5,
    debug: 6,
    verbose: 7,
    silly: 8
};
const colors = {
    none: 'gray',
    critical: 'bold black redBG',
    error: 'bold red',
    warn: 'bold yellow',
    notice: 'magenta',
    info: 'green',
    debug: 'cyan',
    verbose: 'gray',
    silly: 'white',
};
// -----------------------------------
// CONFIGURE TRANSPORTS
let fileLogBaseName = process.env.CS_FILE_LOGGING_BASENAME || 'crownstone-log';
let FILE_LOG_LEVEL = process.env.CS_FILE_LOGGING_LEVEL || 'info';
let CONSOLE_LOG_LEVEL = process.env.CS_CONSOLE_LOGGING_LEVEL || 'info';
let fileLoggingSilent = true;
const SILENT_FLAG_PRESENT = process.argv.indexOf("--silent") >= 0;
if (process.env.CS_ENABLE_FILE_LOGGING === 'true') {
    fileLoggingSilent = false;
}
if (SILENT_FLAG_PRESENT) {
    fileLoggingSilent = true;
}
if (FILE_LOG_LEVEL === 'none') {
    fileLoggingSilent = true;
}
const addFileLoggingToLoggers = function () {
    let loggers = winston.loggers.loggers.keys();
    for (let loggerId of loggers) {
        let logger = winston.loggers.get(loggerId);
        if (!logger) {
            continue;
        }
        if (TransportReferences[loggerId].file) {
            logger.remove(TransportReferences[loggerId].file);
        }
        if (SILENT_FLAG_PRESENT === false) {
            logger.add(generateFileLogger(loggerId));
        }
    }
};
const removeFileLoggingFromLoggers = function () {
    let loggers = winston.loggers.loggers.keys();
    for (let loggerId of loggers) {
        let logger = winston.loggers.get(loggerId);
        if (!logger) {
            continue;
        }
        if (TransportReferences[loggerId].file) {
            logger.remove(TransportReferences[loggerId].file);
            TransportReferences[loggerId].file = null;
        }
    }
};
// -----------------------------------
let TransportReferences = {};
let FileLoggingEnabled = !fileLoggingSilent;
function _createLogger(projectName) {
    if (winston.loggers.has(projectName)) {
        return { logger: winston.loggers.get(projectName), transports: TransportReferences[projectName] };
    }
    let transports = {
        console: new winston.transports.Console({
            level: CONSOLE_LOG_LEVEL,
            format: winston.format.combine(winston.format.colorize(), aggregatedFormat)
        }),
        file: null
    };
    TransportReferences[projectName] = transports;
    let transportsToUse = [transports.console];
    if (FileLoggingEnabled) {
        transports.file = generateFileLogger(projectName);
        transportsToUse.push(transports.file);
    }
    winston.loggers.add(projectName, {
        levels: levels,
        transports: transportsToUse,
    });
    winston.addColors(colors);
    return { logger: winston.loggers.get(projectName), transports: transports };
}
function generateFileLogger(loggerName) {
    let storagePath = process.env.CS_FILE_LOGGING_DIRNAME || 'logs';
    util_1.validatePath(storagePath);
    TransportReferences[loggerName].file = new winston.transports.DailyRotateFile({
        filename: fileLogBaseName + '-%DATE%.log',
        level: FILE_LOG_LEVEL,
        format: aggregatedFormat,
        datePattern: 'YYYY-MM-DD',
        zippedArchive: false,
        dirname: storagePath,
        maxSize: '50m',
        maxFiles: '14d',
        auditFile: path_1.default.join(storagePath, 'crownstone-log-config.json')
    });
    return TransportReferences[loggerName].file;
}
const none = function (logger, filename) {
    return function () { logger.none(filename, ...arguments); };
};
const critical = function (logger, filename) {
    return function () { logger.critical(filename, ...arguments); };
};
const error = function (logger, filename) {
    return function () { logger.error(filename, ...arguments); };
};
const warn = function (logger, filename) {
    return function () { logger.warn(filename, ...arguments); };
};
const notice = function (logger, filename) {
    return function () { logger.notice(filename, ...arguments); };
};
const info = function (logger, filename) {
    return function () { logger.info(filename, ...arguments); };
};
const debug = function (logger, filename) {
    return function () { logger.debug(filename, ...arguments); };
};
const verbose = function (logger, filename) {
    return function () { logger.verbose(filename, ...arguments); };
};
const silly = function (logger, filename) {
    return function () { logger.silly(filename, ...arguments); };
};
function generateCustomLogger(loggerData, projectName, filename) {
    return {
        _logger: loggerData.logger,
        transports: loggerData.transports,
        config: {
            getTransportForLogger: (loggerId) => {
                return TransportReferences[loggerId];
            },
            getLoggerIds: () => {
                return Object.keys(TransportReferences);
            },
            setFileLogging: (state) => {
                if (state) {
                    addFileLoggingToLoggers();
                }
                else {
                    removeFileLoggingFromLoggers();
                }
            },
            setLevel: (level) => {
                CONSOLE_LOG_LEVEL = level;
                FILE_LOG_LEVEL = level;
                Object.keys(TransportReferences).forEach((projectName) => {
                    TransportReferences[projectName].console.level = level;
                    if (TransportReferences[projectName].file) {
                        TransportReferences[projectName].file.level = level;
                    }
                });
            },
            setConsoleLevel: (level) => {
                CONSOLE_LOG_LEVEL = level;
                Object.keys(TransportReferences).forEach((projectName) => {
                    TransportReferences[projectName].console.level = level;
                });
            },
            setFileLevel: (level) => {
                FILE_LOG_LEVEL = level;
                Object.keys(TransportReferences).forEach((projectName) => {
                    if (TransportReferences[projectName].file) {
                        TransportReferences[projectName].file.level = level;
                    }
                });
            }
        },
        none: none(loggerData.logger, projectName + ":" + filename + " - "),
        critical: critical(loggerData.logger, projectName + ":" + filename + " - "),
        error: error(loggerData.logger, projectName + ":" + filename + " - "),
        warn: warn(loggerData.logger, projectName + ":" + filename + " - "),
        notice: notice(loggerData.logger, projectName + ":" + filename + " - "),
        info: info(loggerData.logger, projectName + ":" + filename + " - "),
        debug: debug(loggerData.logger, projectName + ":" + filename + " - "),
        verbose: verbose(loggerData.logger, projectName + ":" + filename + " - "),
        silly: silly(loggerData.logger, projectName + ":" + filename + " - "),
    };
}
exports.generateProjectLogger = function (projectName) {
    return function getLogger(_filename, individialLogger = false) {
        let filename = path_1.default.basename(_filename).replace(path_1.default.extname(_filename), '');
        let evaluatedProjectName = projectName;
        if (individialLogger) {
            evaluatedProjectName = projectName + ":" + filename;
        }
        let customLoggerData = _createLogger(evaluatedProjectName);
        return generateCustomLogger(customLoggerData, evaluatedProjectName, filename);
    };
};
//# sourceMappingURL=ProjectLogger.js.map